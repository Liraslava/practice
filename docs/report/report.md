# Отчёт о выполнении задачи на учебную практику "Кибериммунное устройство мониторинга оборудования (КУМО)"

- [Отчёт о выполнении задачи "КУМО"](#отчёт-о-выполнении-задачи-шлюз-данных)
  - [Постановка задачи\*](#постановка-задачи)
  - [Известные ограничения и вводные\*](#известные-ограничения-и-вводные)
    - [Цели и Предположения Безопасности (ЦПБ)\*](#цели-и-предположения-безопасности-цпб)
      - [Цели\*](#цели)
      - [Предположения\*](#предположения)
  - [Переработанная архитектура решения "КУМО"](#переработанная-архитектура-решения-кумо)
    - [Компоненты](#компоненты-1)
      - [Монитор безопасности (security monitor)](#монитор-безопасности-security-monitor)
    - [Алгоритм работы решения\*](#алгоритм-работы-решения)
    - [Описание cценариев (последовательности выполнения операций), при которых ЦБ нарушаются\*](#описание-cценариев-последовательности-выполнения-операций-при-которых-цб-нарушаются)
      - [Негативный сценарий 1. Менеджер не проверяет обновление](#негативный-сценарий-1-менеджер-не-проверяет-обновление)
      - [Негативный сценарий 2. Менеджер игнорирует результаты проверки](#негативный-сценарий-2-менеджер-игнорирует-результаты-проверки)
      - [Негативный сценарий 3. Storage подменяет файл после проверки](#негативный-сценарий-3-storage-подменяет-файл-после-проверки)
      - [Негативный сценарий 4. Output подключается к device ](#негативный-сценарий-4-output-подключается-к-device)
      - [Негативный сценарий 5. Data input отправляет данные в обратном направлениии](#негативный-сценарий-5-data-input-отправляет-данные-в-обратном-направлении)
      - [Негативный сценарий 6. Verifire отправляет ложный результат проверки](#негативный-сценарий-6-verifire-отправляет-ложный-результат-проверки)
      - [Негативный сценарий 7. Manager не проверяет печать, установленную Verifire](#негативный-сценарий-7-manager-не-проверяет-печать,-установленную-Verifire)
      - [Сводная таблица негативных сценариев\*](#сводная-таблица-негативных-сценариев)
    - [Политика архитектуры \*](#политика-архитектуры-)
      - [Обоснование политики архитектуры \*](#обоснование-политики-архитектуры-)
    - [Политики безопасности\*](#политики-безопасности)
  - [Запуск юнит-тестов\*](#запуск-юнит-теста*)


## Постановка задачи*

Задача заключается в обработке поступающих от оборудования данных и передаче потребителю с возможностью обновления логики работы.

## Известные ограничения и вводные*

По условиям организаторов должна использоваться микросервисная архитектура и шина обмена сообщениями для реализации асинхронной работы сервисов.

### Цели и Предположения Безопасности (ЦПБ)*

#### Цели*

1. обеспечение возможности применения только правильных обновлений.
В данном случае правильный – это некий набор проверок, который мы определили как достаточный.
2. передача данных между системой и устройством работает только в одну сторону

#### Предположения*

1. не рассматриваются атаки, связанные с доставкой обновления на устройство
2. не рассматриваются проблемы доставки обновления на устройство
3. не рассматриваются вопросы физической безопасности устройства
4. можно ограничить выход в интернет для отдельных подсистем решения

## Переработанная архитектура решения "КУМО"
### Компоненты


| Название | Назначение | Комментарий |
|----|----|----|
|*File server* | хранит файлы с обновлением | внешний по отношению к системе сервис, имитатор сервера с обновлениями в интернете |
|*Data input* | сервис с бизнес-логикой: получение входящих данных | бывшее приложение |
|*Data processing* | сервис с бизнес-логикой: обработка входящих данных | бывшее приложение |
|*Data output* | сервис с бизнес-логикой: передача данных внешнему сервису | бывшее приложение |
|*Updater* | непосредственно применяет обновление | работает в одном контейнере с *Data input*, чтобы иметь возможность обновлять его файлы |
|*Downloader*  | скачивает данные из сетей общего пользования. Только этот сервис может выходить во внешние сети | в примере скачивает данные с *File server*.  |
|*Manager* | оркестрирует весь процесс обновления | |
|*Verifier* | проверят корректность скачанного обновления | |
|*Storage* | осуществляет хранение скачанного обновления | |
|*Security monitor*<br>(монитор безопасности) | авторизует операцию, если она удовлетворяет заданным правилам или блокирует её в противном случае| |
|*Message bus* | шина сообщений и брокер - сервис передачи сообщений от источника получателям | kafka+zookeeper |
|

![HLA](./diagrams/docs/report/hla/hla-after.png?raw=true "Изменённая архитектура")



#### Монитор безопасности (security monitor)

На логическом уровне коммуникация выглядит так

![SM](./diagrams/docs/report/sm/sm.png?raw=true "Монитор безопасности")

Т.е. менеджер обновлений поручает сервису verifier проверить обновление, которое тот берёт у сервиса storage, а монитор безопасности проверяет, что вся эта цепочка операций была проделана, и только в этом случае разрешает обратиться к сервису обновления.

### Алгоритм работы решения*

![Sequence diagram](./diagrams/docs/report/sd/sd.png?raw=true "Диаграмма вызовов")

### Описание cценариев (последовательности выполнения операций), при которых ЦБ нарушаются*


Давайте посмотрим на процесс обновления с точки зрения безопасности, чтобы найти потенциальные проблемы, то есть сценарии, где возможна компрометации целей безопасности.

Наши вводные, исходя из выбранного охвата задач: на устройство доставлено обновление и теперь нам надо устройство обновить.

Первая значимая команда в диаграмме – это запрос на проверку и первая возможная проблема, компонент Manager «забыл» отправить запрос на проверку, и таким образом в результате на обновление отправится непроверенная версия.

Следующая значимая команда – запрос на обновление и следующая возможная проблема, это то, что результат проверки может быть проигнорирован и запрос на обновление может отправиться неверная версия обновления.

Следующая возможная проблема уже не связана командами, но она отражает тот факт, что между тем, как обновление проверено и запросом на обновление от Manager есть некий зазор по времени. В этот период времени данные обновления могут быть изменены, и на обновление может отправиться неверная версия обновления.

Следующая возможная проблема - неконтролируемое подключение data_input, data_output к device.

Следующая значимая проблема - verifier отправляет ложный результат проверки.

Следующая значимая проблема - manager не проверяет печать проверки от verifier.

Детальный анализ может выявить ещё и другие проблемы, например, роллбэк атаку и т.д., но для понимания механизмов будет достаточно и самых очевидных. Поэтому, для упрощения политик безопасности примера мы будем рассматривать следующие очевидные сценарии:

1. «забыли» отправить запрос на проверку обновления;
2. результат проверки проигнорировали, не проверили печать;
3. данные обновления изменили после проверки;
4. не ограничили запросы подключения к device;
5. "ложный запрос" проверки.
  
Ниже представлены сценарии компрометации целей безопасности на диаграмме процесса обновления:

![Негативные сценарии](./diagrams/docs/report/sd-negative/sd-negative.png?raw=true "Негативные сценарии")

#### Негативный сценарий 1. Менеджер не проверяет обновление

![Негативный сценарий1](./diagrams/docs/report/sd-negative-manager1/Hacked-manager1.png?raw=true "Менеджер не проверяет обновление")

Результат: недостижение цели безопасности №1: обновление не проверено

#### Негативный сценарий 2. Менеджер игнорирует результаты проверки

![Негативный сценарий2](./diagrams/docs/report/sd-negative-manager2/Hacked-manager2.png?raw=true "Менеджер игнорирует результаты проверки")

Результат: недостижение цели безопасности №1: возможно обновление некорректным файлом

#### Негативный сценарий 3. Storage подменяет файл после проверки

![Негативный сценарий3](./diagrams/docs/report/sd-negative-manager3/Hacked-manager3.png?raw=true "Storage подменяет файл после проверки")

Результат: недостижение цели безопасности №1: обновление непроверенным файлом

#### Негативный сценарий 4. Output подключается к device 

![Негативный сценарий4](./diagrams/docs/report/sd-negative/Negative4_1.png?raw=true "Data output имеет возможность отправить данные на устройство")

Результат: недостижение цели безопасности №2: нарушение однонаправленного обмена данными

#### Негативный сценарий 5. Data input отправляет данные в обратном направлении

![Негативный сценарий5](./diagrams/docs/report/sd-negative/negative5.png?raw=true "Data input отправляет данные обратно на устройство")

Результат: недостижение цели безопасности №2: нарушена однонаправленность передачи данных

#### Негативный сценарий 6. Verifire отправляет ложный результат проверки 

![Негативный сценарий6](./diagrams/docs/report/sd-negative/negative6.png?raw=true "Verifire отправляет ложный результат проверки")

Результат: недостижение цели безопасности №1: возможно обновление некорректным файлом

#### Негативный сценарий 7. Manager не проверяет печать, установленную Verifire

![Негативный сценарий7](./diagrams/docs/report/sd-negative/negative8.png?raw=true "Manager не проверяет печать, установленную Verifire")

Результат: недостижение цели безопасности №1: обновление непроверенным файлом


#### Сводная таблица негативных сценариев*

|№  | Название | Скомпрометированная часть системы | Нарушенная цель безопасности |
|----|----|----|----|
|1 | Менеджер не проверяет обновление | Manager | 1 |
|2 | Менеджер игнорирует результат проверки | Manager | 1 |
|3 |  Storage подменяет файл после проверки  | Storage | 1 |
|4 |  Output подключается к device   | Data output | 2 |
|5 |  Data input отправляет данные в обратном направлении  | Data input | 2 |
|6 |  Verifire отправляет ложный результат проверки   | Verifire | 1 |
|7 |   Manager не проверяет печать, установленную Verifire  | Manager | 1 |

### Политика архитектуры *

В общем случае, компонент Manager может быть недоверенным, результаты проверки могут быть игнорированы или данные могут изменены после проверки, если verifier будет являться сущностью, повышающей доверенность.

Так как шина обмена сообщений и монитор безопасности являются общесистемными, они являются доверенными по умолчанию и на диаграмме не отображаются.

![DFD-update](./diagrams/dfd.png?raw=true "Сущности")

#### Обоснование политики архитектуры *

 | Компонент | Уровень доверия | Обоснование |
|----|----|----|
|Manager|Недоверенный|Не нарушаются ЦБ|
|Data_input|Недоверенный|Не нарушаются ЦБ|
|Data_processor|Недоверенный|Не нарушаются ЦБ|
|Data_output|Недоверенный|Не нарушаются ЦБ|
|Fileserver|Недоверенный|Не нарушаются ЦБ|
|Downloader|Недоверенный|Не нарушаются ЦБ|
|Storage|Недоверенный|Не нарушаются ЦБ|
|App|Недоверенный|Не нарушаются ЦБ|
|Verifier|Повышающий доверие|Нарушается ЦБ 1 - обеспечение возможности применения только правильных обновлений |
|Updater|Повышающий доверие|Нарушается ЦБ 1 - обеспечение возможности применения только правильных обновлений |
|Device|Доверенный|Нет смысла работать над архитектурой, если компонент будет скомпрометирован|

### Политики безопасности*


```python {lineNo:true}

import base64
VERIFIER_SEAL = 'verifier_seal'


def check_operation(id, details):
    authorized = False
    # print(f"[debug] checking policies for event {id}, details: {details}")
    print(f"[info] checking policies for event {id},"
          f" {details['source']}->{details['deliver_to']}: {details['operation']}")
    src = details['source']
    dst = details['deliver_to']
    operation = details['operation']
    if src == 'downloader' and dst == 'manager' \
            and operation == 'download_done':
        authorized = True
    if src == 'manager' and dst == 'downloader' \
            and operation == 'download_file':
        authorized = True
    if src == 'manager' and dst == 'storage' \
            and operation == 'commit_blob':
        authorized = True
    if src == 'manager' and dst == 'verifier' \
            and operation == 'verification_requested':
        authorized = True
    if src == 'verifier' and dst == 'manager' \
            and operation == 'handle_verification_result':
        authorized = True
    if src == 'manager' and dst == 'updater' \
            and operation == 'proceed_with_update' \
            and details['verified'] is True:
        authorized = True
    if src == 'storage' and dst == 'manager' \
            and operation == 'blob_committed':
        authorized = True
    if src == 'storage' and dst == 'verifier' \
            and operation == 'blob_committed':
        authorized = True
    if src == 'verifier' and dst == 'storage' \
            and operation == 'get_blob':
        authorized = True
    if src == 'verifier' and dst == 'storage' \
            and operation == 'commit_sealed_blob' \
            and details['verified'] is True:
        authorized = True
    if src == 'storage' and dst == 'verifier' \
            and operation == 'blob_content':
        authorized = True
    if src == 'updater' and dst == 'storage' \
            and operation == 'get_blob':
        authorized = True
    if src == 'storage' and dst == 'updater' \
            and operation == 'blob_content' and check_payload_seal(details['blob']) is True:
        authorized = True

    return authorized


def check_payload_seal(payload):
    try:
        p = base64.b64decode(payload).decode()
        if p.endswith(VERIFIER_SEAL):
            print('[info] payload seal is valid')
            return True
    except Exception as e:
        print(f'[error] seal check error: {e}')
        return False


```

## Запуск юнит-теста*


from policies import check_operation
import pytest
from params import configurations



@pytest.mark.parametrize('data', configurations)
def test_unit_monitor(data):    
    assert data['result'] == check_operation(data['id'], data)

